<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fractal Mantle - GPGPU Remix</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO & Metadata -->
    <meta name="description" content="A real-time WebGL fractal visualization tool. Explore infinite geometric variations with this interactive raymarcher and export high-resolution 4K wallpapers directly from your browser.">
    <meta name="keywords" content="fractal, raymarcher, three.js, webgl, shader, interactive, 4k wallpaper, generator, gpu rendering, generative art">
    <meta name="author" content="Chris Pirillo">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Fractal Mantle - Interactive GPGPU Raymarcher">
    <meta property="og:description" content="Explore infinite geometric variations with this interactive raymarcher and export high-resolution 4K wallpapers.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/fractal-mantle.png">
    <meta property="og:site_name" content="Pirillo Arcade">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Fractal Mantle">
    <meta name="twitter:description" content="Real-time WebGL fractal visualization and wallpaper generator.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/fractal-mantle.png">

    <!-- Performance: Resource Hints -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="modulepreload" href="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js">

    <style>
        :root {
            --bg-panel: rgba(10, 10, 12, 0.90);
            --border: rgba(255, 255, 255, 0.15);
            --accent: #ff3e00;
            --text: #e0e0e0;
            --text-dim: #888;
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* Canvas Layer */
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; outline: none; }

        /* Transition Curtain */
        #curtain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; pointer-events: none; opacity: 0;
            transition: opacity 0.4s ease-in-out; z-index: 500;
        }
        #curtain.active { opacity: 1; pointer-events: auto; }

        /* UI Overlay */
        #ui-trigger {
            position: absolute; top: 20px; right: 20px; width: 44px; height: 44px;
            background: var(--bg-panel); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-radius: 8px;
            color: var(--text); cursor: pointer; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; transition: all 0.2s;
        }
        #ui-trigger:hover { border-color: var(--accent); }

        /* Settings Panel */
        #settings-panel {
            position: absolute; top: 0; right: 0; width: 340px; height: 100vh;
            background: var(--bg-panel); backdrop-filter: blur(20px);
            border-left: 1px solid var(--border);
            transform: translateX(100%); transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 200; display: flex; flex-direction: column;
        }
        #settings-panel.open { transform: translateX(0); }

        /* Sticky Header */
        .panel-header {
            flex-shrink: 0; height: 60px; display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; border-bottom: 1px solid var(--border); background: rgba(10, 10, 12, 0.95);
        }
        .panel-title { font-weight: 700; letter-spacing: 1px; color: var(--text); font-size: 14px; text-transform: uppercase; }
        .close-btn { 
            cursor: pointer; padding: 8px; color: var(--text); opacity: 0.7; transition: opacity 0.2s; font-size: 20px;
        }
        .close-btn:hover { opacity: 1; color: var(--accent); }

        /* Scrollable Body */
        .panel-body {
            flex-grow: 1; overflow-y: auto; padding: 20px;
            scrollbar-width: thin; scrollbar-color: var(--border) transparent;
        }
        .panel-body::-webkit-scrollbar { width: 4px; }
        .panel-body::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

        /* Controls */
        .section-header {
            color: var(--text); font-size: 10px; text-transform: uppercase; letter-spacing: 2px;
            margin: 25px 0 15px 0; border-bottom: 1px solid var(--border); padding-bottom: 5px; opacity: 0.8;
        }
        .section-header:first-child { margin-top: 0; }
        
        .control-group { margin-bottom: 20px; }
        .control-label { 
            display: flex; justify-content: space-between; font-size: 11px; 
            text-transform: uppercase; letter-spacing: 1px; color: var(--text-dim); margin-bottom: 8px; 
        }
        .control-value { color: var(--accent); font-family: monospace; }
        
        input[type="range"] {
            width: 100%; -webkit-appearance: none; background: transparent; cursor: pointer;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: var(--text); margin-top: -6px; border: 2px solid #000; transition: transform 0.1s;
        }
        input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.2); background: var(--accent); }
        
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 100%; height: 32px; padding: 0; background: none; cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border); border-radius: 4px; }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
        button.action-btn {
            background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            color: var(--text); padding: 12px; border-radius: 4px; cursor: pointer;
            font-size: 11px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;
            transition: all 0.2s;
        }
        button.action-btn:hover { background: rgba(255,255,255,0.1); border-color: var(--text); }
        button.action-btn.primary { background: var(--accent); border-color: var(--accent); color: #000; }
        button.action-btn.primary:hover { opacity: 0.9; }

        /* Modal */
        #info-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); z-index: 1000;
            align-items: center; justify-content: center;
        }
        #info-modal.active { display: flex; }
        .modal-content {
            background: var(--bg-panel); padding: 30px; border-radius: 8px; border: 1px solid var(--border);
            max-width: 400px; width: 90%; text-align: center; position: relative;
        }
        .modal-links a {
            display: block; margin: 12px 0; color: var(--accent); text-decoration: none; font-size: 14px;
        }
        .modal-links a:hover { text-decoration: underline; }
        
        .help-icon {
            display: flex; justify-content: center; align-items: center; width: 24px; height: 24px;
            border: 1px solid var(--text-dim); border-radius: 50%; color: var(--text-dim);
            font-size: 12px; margin: 20px auto 0; cursor: pointer; transition: all 0.2s;
        }
        .help-icon:hover { border-color: var(--accent); color: var(--accent); }

        /* Mobile specific adjustments */
        @media (max-width: 600px) {
            #settings-panel { width: 100%; transform: translateY(100%); bottom: 0; top: auto; height: 80vh; border-left: none; border-top: 1px solid var(--border); }
            #settings-panel.open { transform: translateY(0); }
        }
    </style>
</head>
<body>

    <!-- Curtain for FADE-SWAP-FADE -->
    <div id="curtain"></div>

    <!-- UI Trigger -->
    <div id="ui-trigger" title="Settings" role="button" tabindex="0" aria-label="Open Settings">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </div>

    <!-- Settings Panel -->
    <aside id="settings-panel" aria-label="Settings Panel">
        <div class="panel-header">
            <span class="panel-title">Fractal Mantle</span>
            <div class="close-btn" title="Close" role="button" tabindex="0" aria-label="Close Settings">Ã—</div>
        </div>
        <div class="panel-body">
            <!-- Dynamic Controls Generated by JS -->
            <div id="controls-container"></div>

            <div class="section-header">System</div>
            <div class="control-group">
                <div class="control-label">Management</div>
                <div class="btn-grid">
                    <button class="action-btn" id="btn-randomize">Randomize</button>
                    <button class="action-btn" id="btn-reset">Reset</button>
                </div>
                <div class="btn-grid">
                    <button class="action-btn" id="btn-export-settings">Save JSON</button>
                    <button class="action-btn" onclick="document.getElementById('file-import').click()">Load JSON</button>
                </div>
                <input type="file" id="file-import" accept=".json" style="display: none;">
                <button class="action-btn primary" id="btn-wallpaper" style="width: 100%">Export 4K Wallpaper</button>
            </div>

            <div class="control-group">
                <div class="control-label">
                    <span>Auto-Advance</span>
                    <input type="checkbox" id="auto-advance-toggle" style="accent-color: var(--accent);">
                </div>
                <input type="range" id="auto-advance-speed" min="2" max="30" value="5" aria-label="Auto-advance speed">
                <div style="text-align: right; font-size: 10px; color: var(--text-dim); margin-top: 5px;">
                    <span id="auto-val">5</span>s Interval
                </div>
            </div>

            <div class="help-icon" title="About" role="button" tabindex="0" aria-label="About Information">?</div>
        </div>
    </aside>

    <!-- Info Modal -->
    <div id="info-modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="modal-content">
            <h3 id="modal-title" style="color: var(--text); margin-top: 0;">FRACTAL MANTLE</h3>
            <p style="color: var(--text-dim); font-size: 13px; line-height: 1.5;">
                A GPGPU Raymarcher Remix<br>
                Desktop: Click to Mutate, Drag to Rotate<br>
                Mobile: Double-Tap to Mutate, Drag to Rotate
            </p>
            <div class="modal-links">
                <a href="https://pirillo.com/arcade/" target="_blank" rel="noopener">More Apps</a>
                <a href="https://chris.pirillo.com/" target="_blank" rel="noopener">Follow Chris</a>
            </div>
            <button class="action-btn" id="close-modal" style="margin-top: 15px;">Close (Esc)</button>
        </div>
    </div>

    <!-- ThreeJS Import -->
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } }
    </script>
    
    <script type="module">
        import * as THREE from 'three';

        // --- Core State & Configuration ---
        const config = {
            // Geometry
            fold: 2.5,
            depth: 5,
            scale: 1.5,
            mutationX: 0.0,
            mutationY: 0.0,
            twist: 0.0,
            
            // Camera
            zoom: 15.0, // Adapted default from GPGPU's z=15
            rotX: 0.0,
            rotY: 0.0,
            
            // Rendering / Visuals
            glow: 1.0, 
            glowTightness: 20.0, // Replaces simple divisor
            shadowStrength: 0.8, // Used for contrast in mix
            shininess: 30.0, // Used for glow sharpness
            gloss: 1.0,      // Used for glow brightness
            
            // Animation
            speed: 0.5,
            colorSpeed: 1.0, 
            autoRot: 1.0, 
            
            // Colors
            color1: "#ff3388",
            color2: "#1accff",
            glowColor: "#ffffff",

            // Performance
            quality: 0.5, 
            steps: 64, // GPGPU used 64
        };

        const defaults = { ...config };
        let autoTimer = null;

        // --- Init Scene ---
        const scene = new THREE.Scene();
        // We stick to Ortho camera for the full screen quad, but the shader simulates perspective
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", preserveDrawingBuffer: true });
        
        document.body.appendChild(renderer.domElement);

        function updateResolution() {
            const pixelRatio = Math.min(window.devicePixelRatio, 2) * config.quality;
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(material) material.uniforms.uRes.value.set(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio);
        }

        // --- Shader Material (REMIXED) ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uRes: { value: new THREE.Vector2() },
                
                // Geometry
                uFold: { value: config.fold },
                uDepth: { value: config.depth },
                uScale: { value: config.scale },
                uMutation: { value: new THREE.Vector2(config.mutationX, config.mutationY) },
                uTwist: { value: config.twist },
                
                // Camera
                uZoom: { value: config.zoom },
                uRot: { value: new THREE.Vector2(config.rotX, config.rotY) },
                
                // Render
                uGlow: { value: config.glow },
                uGlowTightness: { value: config.glowTightness },
                uShadowStrength: { value: config.shadowStrength },
                uShininess: { value: config.shininess },
                uGloss: { value: config.gloss },
                uSteps: { value: config.steps },
                uColor1: { value: new THREE.Color(config.color1) },
                uColor2: { value: new THREE.Color(config.color2) },
                uGlowColor: { value: new THREE.Color(config.glowColor) },
                
                // Anim
                uColorSpeed: { value: config.colorSpeed },
                uAutoRot: { value: config.autoRot }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec2 uRes;
                
                uniform float uFold;
                uniform float uDepth;
                uniform float uScale;
                uniform vec2 uMutation;
                uniform float uTwist;
                
                uniform float uZoom;
                uniform vec2 uRot;
                
                uniform float uGlow;
                uniform float uGlowTightness;
                uniform float uShadowStrength;
                uniform float uShininess;
                uniform float uGloss;
                uniform float uSteps;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uGlowColor;
                
                uniform float uColorSpeed;
                uniform float uAutoRot;

                varying vec2 vUv;

                mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }

                // The Map Function (GPGPU Logic + Mantle Inputs)
                float map(vec3 p) {
                    // Internal rotation (Fractal spin)
                    p.xz *= rot(uTime * 0.3 * uAutoRot);
                    p.xy *= rot(uTime * 0.2 * uAutoRot);
                    
                    float s = 1.0;
                    mat2 twistM = rot(uTwist * 0.5); 
                    
                    for(int i = 0; i < 20; i++) {
                        if(i > int(uDepth)) break;
                        
                        // Apply Mantle Twist
                        p.xy *= twistM; 
                        
                        p = abs(p) - uFold;
                        if (p.x < p.y) p.xy = p.yx;
                        if (p.x < p.z) p.xz = p.zx;
                        if (p.y < p.z) p.yz = p.zy;
                        
                        p *= uScale;
                        s *= uScale;
                        
                        // Apply Mantle Mutation (GPGPU used uMouse here)
                        // This moves the "boxes" around
                        p -= vec3(1.0, 5.0, 1.0) * uMutation.x * 2.0; 
                        p -= vec3(0.5, 1.0, 0.5) * uMutation.y * 2.0; 
                    }
                    return (length(p) - 2.0) / s;
                }

                void main() {
                    // Perspective simulation on a flat quad
                    vec2 uv = (gl_FragCoord.xy - 0.5 * uRes.xy) / uRes.y;
                    
                    // Camera Setup (Mantle Orbit Logic)
                    vec3 ro = vec3(0.0, 0.0, -uZoom);
                    vec3 rd = normalize(vec3(uv, 1.0));
                    
                    // Apply Camera Rotation
                    mat2 rx = rot(uRot.y);
                    ro.yz *= rx;
                    rd.yz *= rx;
                    mat2 ry = rot(uRot.x);
                    ro.xz *= ry;
                    rd.xz *= ry;

                    // Raymarching
                    float d = 0.0;
                    float t = 0.0; 
                    
                    vec3 col = vec3(0.0);
                    int maxSteps = int(uSteps);
                    
                    for(int i = 0; i < 150; i++) {
                        if(i >= maxSteps) break;
                        
                        vec3 p = ro + rd * t;
                        d = map(p);
                        
                        // GPGPU Glow Logic
                        // GPGPU Original: col += vec3(...) / (d * 50.0 * (1.0/uGlow));
                        // Adapted for Mantle controls:
                        // uShininess affects the '50.0' factor (sharpness of glow)
                        // uGloss is a global brightness multiplier
                        
                        if(abs(d) < 0.001) {
                            // Hit something solid?
                            // GPGPU didn't really have solid hits, it was all volumetric.
                            // But we break to save performance if we are super close.
                            // We add a burst of color for the "core"
                            col += uGlowColor * 0.1; 
                            break; 
                        }
                        
                        float glowFalloff = max(abs(d), 0.0001);
                        float glowFactor = (0.02 * uGlow) / (glowFalloff * uShininess + 0.01);
                        
                        col += uGlowColor * glowFactor * uGloss;
                        
                        if(t > 50.0) break;
                        t += abs(d) * 0.5; // Step forward
                    }
                    
                    // Depth Coloring (GPGPU Logic)
                    // "col *= mix(vec3(1.0, 0.2, 0.5), vec3(0.1, 0.8, 1.0), sin(t * 0.2));"
                    
                    float depthPhase = t * 0.2 + uTime * uColorSpeed;
                    vec3 depthTint = mix(uColor1, uColor2, sin(depthPhase) * 0.5 + 0.5);
                    
                    // Apply tint
                    col *= depthTint;
                    
                    // Tone Mapping
                    col = col / (1.0 + col);
                    
                    gl_FragColor = vec4(col, 1.0);
                }
            `
        });

        updateResolution();
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(mesh);

        // --- Interaction Logic ---
        let isDragging = false;
        let lastX, lastY;
        let dragDistance = 0;
        const canvas = renderer.domElement;

        canvas.addEventListener('pointerdown', (e) => {
            isDragging = true;
            dragDistance = 0;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            dragDistance += Math.abs(deltaX) + Math.abs(deltaY);

            config.rotX -= deltaX * 0.005;
            config.rotY += deltaY * 0.005;
            config.rotY = Math.max(-1.5, Math.min(1.5, config.rotY));
            
            updateUniforms();
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('pointerup', (e) => {
            isDragging = false;
            canvas.releasePointerCapture(e.pointerId);
            if (e.pointerType === 'mouse' && dragDistance < 5 && !document.getElementById('settings-panel').classList.contains('open')) {
                transition(() => randomize());
            }
        });

        canvas.addEventListener('wheel', (e) => {
            config.zoom += e.deltaY * 0.01;
            config.zoom = Math.max(2.0, Math.min(50.0, config.zoom));
            updateUniforms();
        }, { passive: true });

        // Mobile gestures
        let lastTap = 0;
        let initialPinchDist = null;
        let initialZoom = 0;

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDist = Math.sqrt(dx * dx + dy * dy);
                initialZoom = config.zoom;
            } else if (e.touches.length === 1) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                if (tapLength < 300 && tapLength > 0 && dragDistance < 5) {
                    transition(() => randomize());
                    e.preventDefault();
                }
                lastTap = currentTime;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && initialPinchDist) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const scale = initialPinchDist / dist;
                config.zoom = Math.max(2.0, Math.min(50.0, initialZoom * scale));
                updateUniforms();
                e.preventDefault();
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', () => { initialPinchDist = null; });

        // --- UI Construction ---
        const controlsSchema = [
            { header: "Geometry" },
            { id: 'twist', label: 'Twist', type: 'range', min: -0.5, max: 0.5, step: 0.001 },
            { id: 'fold', label: 'Fold', type: 'range', min: 1.0, max: 4.0, step: 0.01 },
            { id: 'depth', label: 'Recursion', type: 'range', min: 1, max: 10, step: 1 },
            { id: 'scale', label: 'Scale', type: 'range', min: 1.0, max: 2.0, step: 0.01 },
            { id: 'mutationX', label: 'Mutate X', type: 'range', min: -0.45, max: 0.45, step: 0.01 },
            { id: 'mutationY', label: 'Mutate Y', type: 'range', min: -0.45, max: 0.45, step: 0.01 },

            { header: "Visuals" },
            { id: 'shininess', label: 'Glow Sharpness', type: 'range', min: 1.0, max: 100.0, step: 1.0 },
            { id: 'gloss', label: 'Brightness', type: 'range', min: 0.0, max: 3.0, step: 0.01 },
            { id: 'glow', label: 'Glow Amount', type: 'range', min: 0.0, max: 5.0, step: 0.01 },
            { id: 'zoom', label: 'Zoom', type: 'range', min: 2.0, max: 50.0, step: 0.5 },
            
            { header: "Animation" },
            { id: 'speed', label: 'Time Warp', type: 'range', min: 0, max: 2.0, step: 0.1 },
            { id: 'autoRot', label: 'Internal Spin', type: 'range', min: 0, max: 2.0, step: 0.1 },
            { id: 'colorSpeed', label: 'Color Cycle', type: 'range', min: 0, max: 5.0, step: 0.1 },

            { header: "Colors" },
            { id: 'color1', label: 'Deep Color', type: 'color' },
            { id: 'color2', label: 'Far Color', type: 'color' },
            { id: 'glowColor', label: 'Glow Tint', type: 'color' },

            { header: "Performance" },
            { id: 'quality', label: 'Resolution', type: 'range', min: 0.2, max: 1.0, step: 0.1 },
            { id: 'steps', label: 'Max Steps', type: 'range', min: 32, max: 128, step: 8 }
        ];

        const container = document.getElementById('controls-container');

        controlsSchema.forEach(c => {
            if (c.header) {
                const h = document.createElement('div');
                h.className = 'section-header';
                h.innerText = c.header;
                container.appendChild(h);
                return;
            }

            const group = document.createElement('div');
            group.className = 'control-group';
            const labelRow = document.createElement('div');
            labelRow.className = 'control-label';
            const nameSpan = document.createElement('span');
            nameSpan.innerText = c.label;
            const valSpan = document.createElement('span');
            valSpan.className = 'control-value';
            valSpan.id = `val-${c.id}`;
            valSpan.innerText = config[c.id];

            labelRow.appendChild(nameSpan);
            if(c.type === 'range') labelRow.appendChild(valSpan);
            
            const input = document.createElement('input');
            input.type = c.type;
            input.id = c.id;
            if (c.min) input.min = c.min;
            if (c.max) input.max = c.max;
            if (c.step) input.step = c.step;
            input.value = config[c.id];

            input.oninput = (e) => {
                let val = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value;
                config[c.id] = val;
                
                // Special handling for quality which requires resize
                if (c.id === 'quality') updateResolution();
                else updateUniforms();

                if(c.type === 'range') document.getElementById(`val-${c.id}`).innerText = typeof val === 'number' ? val.toFixed(2) : val;
            };

            group.appendChild(labelRow);
            group.appendChild(input);
            container.appendChild(group);
        });

        // --- App Logic ---
        function updateUniforms() {
            material.uniforms.uFold.value = config.fold;
            material.uniforms.uDepth.value = config.depth;
            material.uniforms.uScale.value = config.scale;
            material.uniforms.uMutation.value.set(config.mutationX, config.mutationY);
            material.uniforms.uTwist.value = config.twist;
            
            material.uniforms.uZoom.value = config.zoom;
            material.uniforms.uRot.value.set(config.rotX, config.rotY);
            
            material.uniforms.uGlow.value = config.glow;
            material.uniforms.uGlowTightness.value = config.glowTightness;
            material.uniforms.uShadowStrength.value = config.shadowStrength;
            material.uniforms.uShininess.value = config.shininess;
            material.uniforms.uGloss.value = config.gloss;
            material.uniforms.uSteps.value = config.steps;
            material.uniforms.uColor1.value.set(config.color1);
            material.uniforms.uColor2.value.set(config.color2);
            material.uniforms.uGlowColor.value.set(config.glowColor);
            
            material.uniforms.uColorSpeed.value = config.colorSpeed;
            material.uniforms.uAutoRot.value = config.autoRot;
        }

        function updateUI() {
            controlsSchema.forEach(c => {
                if(c.header) return;
                const el = document.getElementById(c.id);
                if(el) {
                    el.value = config[c.id];
                    if(c.type === 'range') document.getElementById(`val-${c.id}`).innerText = typeof config[c.id] === 'number' ? config[c.id].toFixed(2) : config[c.id];
                }
            });
        }

        function randomize() {
            // Updated randomization for the new visual style
            config.fold = 1.8 + Math.random() * 2.0; 
            config.depth = Math.floor(4 + Math.random() * 4); 
            config.scale = 1.4 + Math.random() * 0.3;
            config.mutationX = (Math.random() * 0.6) - 0.3; 
            config.mutationY = (Math.random() * 0.6) - 0.3;
            config.twist = (Math.random() * 0.4) - 0.2;
            
            config.zoom = 8.0 + Math.random() * 20.0;
            
            config.glow = 1.0 + Math.random() * 2.0; 
            config.shininess = 20.0 + Math.random() * 60.0;
            config.gloss = 0.8 + Math.random() * 0.5;
            
            config.speed = 0.3 + Math.random() * 0.7;
            config.colorSpeed = Math.random() * 2.0;
            config.autoRot = Math.random() * 1.5;

            config.color1 = '#' + new THREE.Color().setHSL(Math.random(), 0.8, 0.4).getHexString();
            config.color2 = '#' + new THREE.Color().setHSL(Math.random(), 0.9, 0.6).getHexString();
            config.glowColor = '#' + new THREE.Color().setHSL(Math.random(), 0.5, 0.8).getHexString();
            
            config.quality = 0.5; 
            config.steps = 64; 

            updateUniforms();
            updateUI();
            updateResolution();
        }

        function transition(actionCallback) {
            const curtain = document.getElementById('curtain');
            curtain.classList.add('active');
            setTimeout(() => {
                actionCallback();
                setTimeout(() => curtain.classList.remove('active'), 100);
            }, 450);
        }

        // --- Wiring ---
        const panel = document.getElementById('settings-panel');
        const trigger = document.getElementById('ui-trigger');
        const closeBtn = document.querySelector('.close-btn');

        function toggleMenu(e) {
            e.stopPropagation();
            panel.classList.toggle('open');
            trigger.style.opacity = panel.classList.contains('open') ? '0' : '1';
        }
        trigger.onclick = toggleMenu;
        closeBtn.onclick = toggleMenu;

        document.addEventListener('click', (e) => {
            if (panel.classList.contains('open') && !panel.contains(e.target) && e.target !== trigger) {
                panel.classList.remove('open');
                trigger.style.opacity = '1';
            }
        });
        panel.addEventListener('pointerdown', e => e.stopPropagation());
        trigger.addEventListener('pointerdown', e => e.stopPropagation());

        document.getElementById('btn-randomize').onclick = () => transition(() => randomize());
        document.getElementById('btn-reset').onclick = () => transition(() => {
            Object.assign(config, defaults);
            updateUniforms();
            updateUI();
            updateResolution();
        });

        document.getElementById('btn-wallpaper').onclick = () => {
            const width = 3840;
            const height = 2160;
            renderer.setSize(width, height);
            const pixelRatio = 1; 
            material.uniforms.uRes.value.set(width, height); 
            material.uniforms.uSteps.value = 128;
            renderer.render(scene, camera);
            
            const link = document.createElement('a');
            link.download = `FractalMantle_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();

            material.uniforms.uSteps.value = config.steps;
            updateResolution();
        };

        document.getElementById('btn-export-settings').onclick = () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config));
            const link = document.createElement('a');
            link.href = dataStr;
            link.download = `FractalMantle_Settings_${new Date().toISOString().slice(0,19).replace(/:/g,"-")}.json`;
            link.click();
        };

        document.getElementById('file-import').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loaded = JSON.parse(e.target.result);
                    Object.assign(config, loaded);
                    transition(() => { updateUniforms(); updateUI(); updateResolution(); });
                } catch(err) { alert('Invalid JSON'); }
            };
            reader.readAsText(file);
        };

        const autoCheck = document.getElementById('auto-advance-toggle');
        const autoSpeed = document.getElementById('auto-advance-speed');
        autoSpeed.oninput = (e) => {
            document.getElementById('auto-val').innerText = e.target.value;
            if(autoCheck.checked) startAuto();
        };
        function startAuto() {
            if(autoTimer) clearInterval(autoTimer);
            autoTimer = setInterval(() => transition(() => randomize()), parseInt(autoSpeed.value) * 1000);
        }
        autoCheck.onchange = (e) => { e.target.checked ? startAuto() : clearInterval(autoTimer); };

        const modal = document.getElementById('info-modal');
        document.querySelector('.help-icon').onclick = () => modal.classList.add('active');
        document.getElementById('close-modal').onclick = () => modal.classList.remove('active');
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                modal.classList.remove('active');
                if(panel.classList.contains('open')) {
                    panel.classList.remove('open');
                    trigger.style.opacity = '1';
                }
            }
        });

        // --- Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            const t = time * 0.001 * config.speed;
            material.uniforms.uTime.value = t;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', updateResolution);

        // Start with a randomized state that looks good
        randomize();
        animate(0);
    </script>
</body>
</html>